<div class="RichContent RichContent--unescapable"><span><div class="RichContent-inner"><div class="css-376mun"><span class="RichText ztext CopyrightRichText-richText css-1g0fqss" itemprop="text" options="[object Object]"><p data-first-child="" data-pid="2C-NNqUQ">当年上我老板的OS课，老板上来就告诉我们，OS不是运行着的代码，而是一堆躺在内存里等着被调用的代码。</p><p data-pid="HdFfHtUd">内核就是一个由interrupt驱动的程序。这个interrupt可以是一个系统调用（x86下，很多OS的系统调用是靠software interrupt实现的），可以是一个用户程序产生的异常，也可以是一个硬件产生的事件中断。</p><p data-pid="mZtEWcTI">于是你的问题解决了：一个用户程序运行的时候，Linux就在内存里呆着，等着一个中断的到来。在这个中断的处理过程中，来做“调度”。而一般的时分系统里，都会有个timer interrupt每隔一段时间到来，也就是楼上说的“时间片”。</p><p data-pid="2o0qI6kK">PS：很多人在认识OS的过程中被大量的artificial concept给困惑了。比如神马进程，线程，调度，micro kernel，monolithic kernel的。从x86架构上来理解OS才是王道。</p><p data-pid="yc96ls55">=================================================================</p><p data-pid="qByY0fwh">PS of PS: 把评论粘上来，补充上面的PS，谢 </p><a class="member_mention" data-editable="true" data-hash="00cac8fef58a8c5505097dfc01a4706b" data-hovercard="p$b$00cac8fef58a8c5505097dfc01a4706b" data-title="@许越" href="https://www.zhihu.com/people/00cac8fef58a8c5505097dfc01a4706b">@许越</a><p data-pid="DdQ7-j6b">提醒：</p><p data-pid="n-REh80p">因为很多教材在讲os的时候，更喜欢从app的角度来看待os，于是很多时候被各种概念绑架。因为很多例如进城，线程，系统调用这样的东西都是由os在硬件上抽象出来的。站在这些概念上看os，就有点“不识庐山真面目”的感觉。所以我的意思是从硬件的角度看os，反过来理解为何os要抽象出这些概念。站在cpu的角度，理解指令是怎么在cpu上一条一条的运行的。</p></span></div></div></span><div><div class="ContentItem-time"><a href="//www.zhihu.com/question/23561375/answer/25345790" target="_blank"><span aria-label="发布于 2014-05-08 04:00" data-tooltip="发布于 2014-05-08 04:00">编辑于 2014-05-08 10:38</span></a></div></div><span></span></div>