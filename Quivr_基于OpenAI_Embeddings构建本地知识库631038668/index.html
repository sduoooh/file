<div class="CollectionItem"><div></div><h1>Quivr 基于OpenAI Embeddings构建本地知识库</h1><div class="RichText ztext Post-RichText css-1g0fqss" options="[object Object]"><h2 data-first-child="">一、Quivr介绍</h2><img loading="lazy" onerror="this.src='https://collection.sduoooh.me/Quivr_基于OpenAI_Embeddings构建本地知识库631038668/img/12.jpg';this.onerror=null;" src="./img/12.jpg" aspect-ratio ="2.23407917383821"><p data-pid="LTYiI9og">Quivr可以帮助把你的本地文件向量化，然后存储到云端，随时可以查询对话。文档格式支持Text、Markdown、 PDF、音频和视频。GPT端支持ChatGPT-3/4和Claude。 向量数据库使用的是Supabase ，音视频是基于Whisper的API处理成文本的，主要语言是Python开发。</p><img loading="lazy" onerror="this.src='https://collection.sduoooh.me/Quivr_基于OpenAI_Embeddings构建本地知识库631038668/img/13.jpg';this.onerror=null;" src="./img/13.jpg" aspect-ratio ="2.0587392550143266"><p data-pid="1B3e4lxG">Quivr可以将我们的本地文件存储在向量数据库中，然后存储到云端，随时可以查询对话。使用 OpenAI 的 GPT-3/4 或者Claude 100k对其进行查询。</p><p data-pid="0nN4AC8D">Quivr是一个功能强大而高效的数据管理工具。它可以轻松地处理各种类型的数据，无论是文本、图像还是代码片段等等。</p><p data-pid="ifXnvmUh">Quivr兼容多种文件格式，包括文本、Markdown、PDF、Powerpoint、Excel、Word、音频和视频，使其成为一个非常适合多样化需求的数据管理工具。</p><p data-pid="kKT2Bfj1">Quivr采用先进的人工智能技术，可帮助您生成和检索信息，让您的数据管理更加智能和高效。这款设计迅捷高效的工具确保您在访问和使用数据时得到最快的响应速度。Quivr的速度和效率会在日常工作中让您受益无穷。</p><p data-pid="ONQ9p9DS">您的数据始终处于您的掌控之下，Quivr保证您的数据安全性，让您放心使用。</p><p data-pid="9lbbS3aZ">此外，Quivr开源且免费使用，让您更加自由地使用这个优秀的工具。</p><p data-pid="hAT50OUh"><b>注意：在公开的演示系统中，因为功能访问受到限制。只能使用 GPT-3.5-turbo 模型并上传最大 1Mb 的文件。如果需要使用更多模型并上传更大的文件，需要自行部署 Quivr托管。</b></p><p data-pid="sahlolFe">项目地址：<a class="external" href="https://link.zhihu.com/?target=https%3A//github.com/StanGirard/quivr" rel="nofollow noreferrer" target="_blank"><span class="invisible">https://</span><span class="visible">github.com/StanGirard/q</span><span class="invisible">uivr</span><span class="ellipsis"></span></a></p><h2>二、Quivr特性</h2><ul><li data-pid="eYiowLGN"><b>存储任何文件：</b>Quivr可以处理几乎所有类型的数据。文本、图像、代码片段等等，您只需要说出来。</li><li data-pid="QTp3PY_L"><b>生成式人工智能</b>：Quivr使用先进的人工智能技术来帮助您生成和检索信息。</li><li data-pid="DAPE6ebu"><b>快速高效</b>：Quivr专为速度和效率而设计，以确保您能够尽快访问自己的数据。</li><li data-pid="f8pzt5Nv"><b>安全可靠</b>：您的数据始终在您的控制下。</li><li data-pid="gboTdkEf"><b>兼容文件格式</b>： TXT、CSV、MD、MARKDOWN、M4A、MP3、WEBM、MP4、MPGA、WAV、MPEG、PDF、HTML、PPTX、DOCX（每个文件限制200M）</li><li data-pid="1DgK6ycR"><b>开源免费</b>：Quivr是开源的，并且可以免费使用。</li></ul><h2>三、Quivr演示</h2><p data-pid="G-miJ5Wt">接下来我们会基于GPT-3.5、GPT-4、Claude 100K三种GPT模型来演示Quivr上传本地文件到向量数据库并及时进行文本内容检索。</p><h2>3.1、基于GPT-3.5模型演示</h2><img loading="lazy" onerror="this.src='https://collection.sduoooh.me/Quivr_基于OpenAI_Embeddings构建本地知识库631038668/img/14.jpg';this.onerror=null;" src="./img/14.jpg" aspect-ratio ="1.474074074074074"><h2>3.2、基于GPT-4模型演示</h2><img loading="lazy" onerror="this.src='https://collection.sduoooh.me/Quivr_基于OpenAI_Embeddings构建本地知识库631038668/img/15.jpg';this.onerror=null;" src="./img/15.jpg" aspect-ratio ="1.474074074074074"><h2>3.3、基于Claude 100k context模型演示</h2><img loading="lazy" onerror="this.src='https://collection.sduoooh.me/Quivr_基于OpenAI_Embeddings构建本地知识库631038668/img/16.jpg';this.onerror=null;" src="./img/16.jpg" aspect-ratio ="1.3934977578475336"><h2>四、Quivr部署</h2><h2>4.1、前提条件</h2><p data-pid="HJfJqXP3">在继续部署之前，请确保已安装以下内容:</p><ul><li data-pid="D6lZbkbn">Docker</li><li data-pid="bayJJSsB">Docker Compose</li></ul><p data-pid="zwSkdL2v">您还需要Supabase账户，以获得以下内容：</p><ul><li data-pid="ZckUhdn9">新建Supabase项目</li></ul><img loading="lazy" onerror="this.src='https://collection.sduoooh.me/Quivr_基于OpenAI_Embeddings构建本地知识库631038668/img/17.jpg';this.onerror=null;" src="./img/17.jpg" aspect-ratio ="1.0676100628930818"><ul><li data-pid="WoNiaplj">Supabase项目API密钥</li><li data-pid="cLKbtUHg">Supabase项目URL</li></ul><h2>4.2、安装Quivr</h2><h2>4.2.1、克隆存储库</h2><div class="highlight"><pre><code class="language-powershell"><span class="n">git</span> <span class="n">clone</span> <span class="n">git</span><span class="nv">@github</span><span class="p">.</span><span class="n">com</span><span class="err">:</span><span class="n">StanGirard</span><span class="p">/</span><span class="n">Quivr</span><span class="p">.</span><span class="n">git</span> <span class="p">&amp;&amp;</span> <span class="nb">cd </span><span class="n">Quivr</span></code></pre></div><ul><li data-pid="gO59BTVF">因为包含隐藏文件，可以使用 <b>ls -alh</b> 命令查看所有文件</li></ul><img loading="lazy" onerror="this.src='https://collection.sduoooh.me/Quivr_基于OpenAI_Embeddings构建本地知识库631038668/img/18.jpg';this.onerror=null;" src="./img/18.jpg" aspect-ratio ="2.645051194539249"><h2>4.2.2、复制.XXXXX_env文件</h2><div class="highlight"><pre><code class="language-bash">cp .backend_env.example .backend_env
cp .frontend_env.example .frontend_env</code></pre></div><h2>4.2.3、更新.backend_env文件</h2><div class="highlight"><pre><code class="language-properties">SUPABASE_URL=""
SUPABASE_SERVICE_KEY="eyXXXXX"
OPENAI_API_KEY="sk-XXXXXX"
anthropic_api_key="XXXXXX"</code></pre></div><p data-pid="CtjXCB4F"><i>请注意，supabase_url</i>在您的<i>Supabase仪表板下的项目设置-&gt; API中对应的Project URL，supabase_service_key在您的Supabase仪表板下的项目设置-&gt; API中找到。使用“Project API keys”部分中找到的anon public键。</i></p><img loading="lazy" onerror="this.src='https://collection.sduoooh.me/Quivr_基于OpenAI_Embeddings构建本地知识库631038668/img/19.jpg';this.onerror=null;" src="./img/19.jpg" aspect-ratio ="1.242530755711775"><h2>4.2.4、创建Supabase数据库和表</h2><p data-pid="UhNe5FGR">通过Web界面（SQL编辑器-&gt;“新查询”）在Supabase数据库上运行以下迁移脚本</p><img loading="lazy" onerror="this.src='https://collection.sduoooh.me/Quivr_基于OpenAI_Embeddings构建本地知识库631038668/img/20.jpg';this.onerror=null;" src="./img/20.jpg" aspect-ratio ="2.060882800608828"><img loading="lazy" onerror="this.src='https://collection.sduoooh.me/Quivr_基于OpenAI_Embeddings构建本地知识库631038668/img/21.jpg';this.onerror=null;" src="./img/21.jpg" aspect-ratio ="2.582577132486388"><div class="highlight"><pre><code class="language-sql"><span class="c1">-- Enable the pgvector extension to work with embedding vectors
</span><span class="c1"></span>       <span class="k">create</span> <span class="n">extension</span> <span class="n">vector</span><span class="p">;</span>

       <span class="c1">-- Create a table to store your documents
</span><span class="c1"></span>       <span class="k">create</span> <span class="k">table</span> <span class="n">documents</span> <span class="p">(</span>
       <span class="n">id</span> <span class="n">bigserial</span> <span class="k">primary</span> <span class="k">key</span><span class="p">,</span>
       <span class="n">content</span> <span class="nb">text</span><span class="p">,</span> <span class="c1">-- corresponds to Document.pageContent
</span><span class="c1"></span>       <span class="n">metadata</span> <span class="n">jsonb</span><span class="p">,</span> <span class="c1">-- corresponds to Document.metadata
</span><span class="c1"></span>       <span class="n">embedding</span> <span class="n">vector</span><span class="p">(</span><span class="mi">1536</span><span class="p">)</span> <span class="c1">-- 1536 works for OpenAI embeddings, change if needed
</span><span class="c1"></span>       <span class="p">);</span>

       <span class="k">CREATE</span> <span class="k">FUNCTION</span> <span class="n">match_documents</span><span class="p">(</span><span class="n">query_embedding</span> <span class="n">vector</span><span class="p">(</span><span class="mi">1536</span><span class="p">),</span> <span class="n">match_count</span> <span class="nb">int</span><span class="p">)</span>
           <span class="k">RETURNS</span> <span class="k">TABLE</span><span class="p">(</span>
               <span class="n">id</span> <span class="nb">bigint</span><span class="p">,</span>
               <span class="n">content</span> <span class="nb">text</span><span class="p">,</span>
               <span class="n">metadata</span> <span class="n">jsonb</span><span class="p">,</span>
               <span class="c1">-- we return matched vectors to enable maximal marginal relevance searches
</span><span class="c1"></span>               <span class="n">embedding</span> <span class="n">vector</span><span class="p">(</span><span class="mi">1536</span><span class="p">),</span>
               <span class="n">similarity</span> <span class="nb">float</span><span class="p">)</span>
           <span class="k">LANGUAGE</span> <span class="n">plpgsql</span>
           <span class="k">AS</span> <span class="err">$$</span>
           <span class="o">#</span> <span class="n">variable_conflict</span> <span class="n">use_column</span>
       <span class="k">BEGIN</span>
           <span class="k">RETURN</span> <span class="n">query</span>
           <span class="k">SELECT</span>
               <span class="n">id</span><span class="p">,</span>
               <span class="n">content</span><span class="p">,</span>
               <span class="n">metadata</span><span class="p">,</span>
               <span class="n">embedding</span><span class="p">,</span>
               <span class="mi">1</span> <span class="o">-</span><span class="p">(</span><span class="n">documents</span><span class="p">.</span><span class="n">embedding</span> <span class="o">&lt;=&gt;</span> <span class="n">query_embedding</span><span class="p">)</span> <span class="k">AS</span> <span class="n">similarity</span>
           <span class="k">FROM</span>
               <span class="n">documents</span>
           <span class="k">ORDER</span> <span class="k">BY</span>
               <span class="n">documents</span><span class="p">.</span><span class="n">embedding</span> <span class="o">&lt;=&gt;</span> <span class="n">query_embedding</span>
           <span class="k">LIMIT</span> <span class="n">match_count</span><span class="p">;</span>
       <span class="k">END</span><span class="p">;</span>
       <span class="err">$$</span><span class="p">;</span></code></pre></div><p data-pid="41C7quO0">and</p><div class="highlight"><pre><code class="language-sql"><span class="k">create</span> <span class="k">table</span>
  <span class="n">stats</span> <span class="p">(</span>
    <span class="c1">-- A column called "time" with data type "timestamp"
</span><span class="c1"></span>    <span class="n">time</span> <span class="k">timestamp</span><span class="p">,</span>
    <span class="c1">-- A column called "details" with data type "text"
</span><span class="c1"></span>    <span class="n">chat</span> <span class="nb">boolean</span><span class="p">,</span>
    <span class="n">embedding</span> <span class="nb">boolean</span><span class="p">,</span>
    <span class="n">details</span> <span class="nb">text</span><span class="p">,</span>
    <span class="n">metadata</span> <span class="n">jsonb</span><span class="p">,</span>
    <span class="c1">-- An "integer" primary key column called "id" that is generated always as identity
</span><span class="c1"></span>    <span class="n">id</span> <span class="nb">integer</span> <span class="k">primary</span> <span class="k">key</span> <span class="k">generated</span> <span class="n">always</span> <span class="k">as</span> <span class="k">identity</span>
  <span class="p">);</span></code></pre></div><img loading="lazy" onerror="this.src='https://collection.sduoooh.me/Quivr_基于OpenAI_Embeddings构建本地知识库631038668/img/22.jpg';this.onerror=null;" src="./img/22.jpg" aspect-ratio ="3.549019607843137"><h2>4.2.5、构建并启动Quivr</h2><div class="highlight"><pre><code class="language-powershell"><span class="n">docker-compose</span> <span class="n">build</span> <span class="p">&amp;&amp;</span> <span class="n">docker-compose</span> <span class="n">up</span></code></pre></div><p data-pid="4IqxNqfY"><b>温馨提示：</b>这个启动过程需要安装非常多的依赖库，时间会根据你的网络情况不太一样，如果执行过程中出错，可以检查一下Docker和Python的版本是否是比较新的，如果是因为中途下载以来超时，可以继续再执行一下，不出意外，看到下面的输出信息说明已成功构建并启动前端和后端应用。</p><img loading="lazy" onerror="this.src='https://collection.sduoooh.me/Quivr_基于OpenAI_Embeddings构建本地知识库631038668/img/23.jpg';this.onerror=null;" src="./img/23.jpg" aspect-ratio ="1.8614357262103507"><img loading="lazy" onerror="this.src='https://collection.sduoooh.me/Quivr_基于OpenAI_Embeddings构建本地知识库631038668/img/24.jpg';this.onerror=null;" src="./img/24.jpg" aspect-ratio ="2.0615615615615615"><h2>4.2.6、访问Quivr</h2><p data-pid="Z34B4FVV">启动成功后在浏览器直接访问3000端口，可以看到项目主页：</p><img loading="lazy" onerror="this.src='https://collection.sduoooh.me/Quivr_基于OpenAI_Embeddings构建本地知识库631038668/img/25.jpg';this.onerror=null;" src="./img/25.jpg" aspect-ratio ="2.3386524822695036"><h2>五、实现原理</h2><p data-pid="6N1WUldk">Quivr兼容多种文件格式，包括文本、Markdown、PDF、Powerpoint、Excel、Word、音频和视频，使其成为一个非常适合多样化需求的数据管理工具。</p><h2>5.1、文件加载器（计算元数据）</h2><p data-pid="euveFV0o">例如上传Markdown文件时会调用Markdown Loader。（<b>使用LangChainAI实现</b>）</p><p data-pid="ZZPaImr3">1、加载 Markdown</p><p data-pid="nxOAml_D">2 - 计算文件的 SHA1</p><p data-pid="AsVZVWCZ">3 - 添加 SHA1 作为元数据</p><p data-pid="RHyekRa6">4 - 添加到Supabase vectorstore ,下次如果文件具有相同的 SHA1 则不会上传</p><img loading="lazy" onerror="this.src='https://collection.sduoooh.me/Quivr_基于OpenAI_Embeddings构建本地知识库631038668/img/26.jpg';this.onerror=null;" src="./img/26.jpg" aspect-ratio ="2.0495726495726494"><h2>5.2、文件存储（拆分&amp;向量化）</h2><p data-pid="pczwXWRw">然后将文档拆分并存储到Supabase vectorstore中，存储的主要信息包括：</p><p data-pid="C0fNhpdE">1 - 它是文件的内容</p><p data-pid="gIrSTAe1">2 - 文件的元数据信息</p><p data-pid="f5Q-ByYY">3 - 使用OpenAI Embeddings来计算文件的向量值</p><img loading="lazy" onerror="this.src='https://collection.sduoooh.me/Quivr_基于OpenAI_Embeddings构建本地知识库631038668/img/27.jpg';this.onerror=null;" src="./img/27.jpg" aspect-ratio ="2.056603773584906"><h2>5.3、重复文件校验</h2><p data-pid="AAKd-JuJ">文件已经上传，每当上传新文件时：</p><p data-pid="XUkaeIG3">1 - 通过计算文件 SHA1 来检查它是否已经存在</p><p data-pid="JenwOtV7">2 - 通过查询Supabase元数据列来检查它</p><img loading="lazy" onerror="this.src='https://collection.sduoooh.me/Quivr_基于OpenAI_Embeddings构建本地知识库631038668/img/28.jpg';this.onerror=null;" src="./img/28.jpg" aspect-ratio ="1.9230769230769231"><h2>5.4、模型选择</h2><p data-pid="mtB_wyLT">1 - 选择模型（GPT3.5 或 GPT4）</p><p data-pid="yE8rUv1V">2 - 使用Supabase vectorstore 创建 CoversationalRetrievalChain</p><p data-pid="t9Fw5RUr">3 - 发送问题，然后在Streamlit中显示查询结果</p><img loading="lazy" onerror="this.src='https://collection.sduoooh.me/Quivr_基于OpenAI_Embeddings构建本地知识库631038668/img/29.jpg';this.onerror=null;" src="./img/29.jpg" aspect-ratio ="3.2085561497326203"><h2>5.5、文件上传</h2><p data-pid="SIrTfH4J">现在我们可以上传文件，例如 Markdown，音频文件（将由 Whisper 转录为文本）后上传到Supabase中</p><img loading="lazy" onerror="this.src='https://collection.sduoooh.me/Quivr_基于OpenAI_Embeddings构建本地知识库631038668/img/30.jpg';this.onerror=null;" src="./img/30.jpg" aspect-ratio ="1.2944983818770226"><h2>5.6、对话检索</h2><p data-pid="gJ1OWi1M">最后使用OpenAI GPT4 或 GPT3.5 的接口查询</p><img loading="lazy" onerror="this.src='https://collection.sduoooh.me/Quivr_基于OpenAI_Embeddings构建本地知识库631038668/img/31.jpg';this.onerror=null;" src="./img/31.jpg" aspect-ratio ="1.7301587301587302"><h2>六、FAQ</h2><h2>6.1、Docker建议安装最新的版本</h2><p data-pid="OrMp0kjt">不能低于17，否则会出现不支持--iidfile的错误，安装新版本需要先卸载老版本，具体可查阅官方文档：<a class="external" href="https://link.zhihu.com/?target=https%3A//docs.docker.com/engine/install/centos/" rel="nofollow noreferrer" target="_blank"><span class="invisible">https://</span><span class="visible">docs.docker.com/engine/</span><span class="invisible">install/centos/</span><span class="ellipsis"></span></a>。</p><blockquote data-pid="wj7qlNwS">--iidfile 标志是在 Docker 17.05 版本中引入的。因此，如果您使用的是 Docker 17.05 版本或更高版本，则应该支持 --iidfile 标志。如果您使用的是旧版本的 Docker，则可能不支持 --iidfile 标志。</blockquote><h2>6.2、Python版本需要安装3.11版本</h2><p data-pid="PD53fAXv">在 CentOS 中将 安装Python 3.11</p><ul><li data-pid="YfnEYr5G">首先，您需要安装 EPEL 存储库。EPEL 存储库包含许多额外的软件包，这些软件包不包含在 CentOS 的官方存储库中。您可以使用以下命令安装 EPEL 存储库：</li></ul><div class="highlight"><pre><code class="language-powershell"><span class="n">sudo</span> <span class="n">yum</span> <span class="n">install</span> <span class="n">epel-release</span></code></pre></div><ul><li data-pid="RVRqP9nd">接下来，您需要安装一些必要的软件包和工具，以便编译 Python 3.11。您可以使用以下命令安装这些软件包：</li></ul><div class="highlight"><pre><code class="language-text">sudo yum install gcc openssl-devel bzip2-devel libffi-devel zlib-devel wget</code></pre></div><ul><li data-pid="r0_7bhYp">然后，您需要下载 Python 3.11 的源代码。您可以从 Python 官方网站下载最新版本的源代码，然后使用以下命令下载并解压缩源代码：</li></ul><div class="highlight"><pre><code class="language-text">wget https://www.python.org/ftp/python/3.11.0/Python-3.11.0.tgz
tar xzf Python-3.11.0.tgz</code></pre></div><ul><li data-pid="Zh8D1HjX">接下来，进入解压缩后的 Python 源代码目录，并使用以下命令编译和安装 Python 3.11：</li></ul><div class="highlight"><pre><code class="language-text">cd Python-3.11.0
./configure --enable-optimizations
make altinstall</code></pre></div><p data-pid="mF9Q7Kj9">注意，使用 make altinstall 命令而不是 make install 命令，这将确保您的系统上同时存在 Python 2.7 和 Python 3.11。</p><ul><li data-pid="wsMq32p-">最后，您需要验证 Python 3.11 是否正确安装。您可以使用以下命令检查 Python 3.11 的版本：</li></ul><div class="highlight"><pre><code class="language-text">python3.11 --version</code></pre></div><p data-pid="484jiRh1">如果您看到类似于以下内容的输出，则表示 Python 3.11 已经成功安装：</p><div class="highlight"><pre><code class="language-text">Python 3.11.0</code></pre></div><p data-pid="MEQemaT4">请注意，升级 Python 版本可能会影响到系统的其他部分，因此请在操作之前备份您的系统，并确保您知道如何恢复到先前的状态。</p><p></p></div><link href="../style.css" rel="stylesheet"/><div class="ContentItem-time" role="button" tabindex="0"><a href="https://zhuanlan.zhihu.com/p/631038668">发布于 2023-05-21 18:39</a><span>・IP 属地广东</span></div></div>